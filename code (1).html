<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圆形移动游戏 (移动修复)</title>
    <style>
        /* CSS remains the same */
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f0f0f0; font-family: 'Arial', sans-serif; }
        #game-container { position: relative; width: 1280px; height: 720px; border: 1px solid #ccc; overflow: hidden; background-color: #e0e0e0; display: flex; justify-content: center; align-items: center; }
        .game-button { padding: 15px 30px; font-size: 24px; color: white; border: none; border-radius: 8px; cursor: pointer; transition: transform 0.1s ease-out, background-color 0.1s ease-out; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10; position: absolute; }
        #play-button { background-color: #4CAF50; }
        #play-button:hover { background-color: #45a049; }
        #play-button:active { transform: scale(0.95); background-color: #3e8e41; }
        #replay-button { background-color: #2196F3; display: none; }
        #replay-button:hover { background-color: #1e88e5; }
        #replay-button:active { transform: scale(0.95); background-color: #1976d2; }
        #line { position: absolute; left: 0; bottom: 50px; width: 200%; height: 2px; background-color: #333; animation: moveGround 2s linear infinite; display: none; z-index: 0; }
        @keyframes moveGround { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
        #circle { position: absolute; width: 50px; height: 50px; border-radius: 50%; background-color: #000; display: none; transition: width 0.05s ease-out, height 0.05s ease-out, opacity 0.05s linear; z-index: 3; }
       .obstacle { position: absolute; background-color: black; z-index: 2; }
       .particle { position: absolute; width: 6px; height: 6px; background-color: #333; border-radius: 50%; z-index: 4; }
       #charge-ring-svg { position: absolute; pointer-events: none; z-index: 5; }
       #charge-ring-path { transition: stroke-dashoffset 0.05s linear, stroke 0.1s linear, opacity 0.1s linear; }
       #score-display { position: absolute; top: 15px; right: 20px; font-size: 28px; font-weight: bold; color: #333; z-index: 5; }
    </style>
</head>

<body>
    <div id="game-container">
        <button id="play-button" class="game-button">PLAY</button>
        <button id="replay-button" class="game-button">REPLAY</button>
        <div id="line"></div>
        <div id="circle"></div>
        <div id="score-display">得分: 0</div>
    </div>
    <script>
        const GAME_CONTAINER_ELEMENT = document.getElementById('game-container');
        const CIRCLE_ELEMENT = document.getElementById('circle');
        const LINE_ELEMENT = document.getElementById('line');
        const PLAY_BUTTON_ELEMENT = document.getElementById('play-button');
        const REPLAY_BUTTON_ELEMENT = document.getElementById('replay-button');
        const SCORE_DISPLAY_ELEMENT = document.getElementById('score-display'); 

        let gameState = "menu"; 
        let animationFrameId = null;

        let GAME_WIDTH = 1280; 
        let GAME_HEIGHT = 720;
        const GROUND_LEVEL = 50;

        const CIRCLE_BASE_WIDTH = 50; const CIRCLE_BASE_HEIGHT = 50;
        let circleWidth = CIRCLE_BASE_WIDTH; let circleHeight = CIRCLE_BASE_HEIGHT;
        let circleX = GAME_WIDTH * 0.1; let circleY = GROUND_LEVEL;

        let velocity = 0; const acceleration = 0.5; const maxVelocity = 7; const deceleration = 0.25;
        let isJumping = false; let jumpVelocity = 0; 
        const jumpPower = 22; 
        const upGravity = 0.7; const downGravity = 0.5; 
        const obstacleGravity = 0.6; 
        let maxAchievableJumpHeight = 0; 

        let isMovingLeft = false; let isMovingRight = false; let isShiftHeld = false;

        const obstacleMinWidth = 40; const obstacleMaxWidth = 60; 
        const obstacleMinHeight = 80;  const obstacleMaxHeight = 160; 

        const INITIAL_OBSTACLE_SPEED = 3.0; 
        let currentObstacleSpeed = INITIAL_OBSTACLE_SPEED; 
        const OBSTACLE_SPEED_INCREMENT = 0.15; 
        let lastSpeedIncreaseScore = 0; 
        const pushForce = 6;

        const obstacles = []; 
        let obstacleTimer = 0; 
        const obstacleSpawnIntervalMin = 70; const obstacleSpawnIntervalMax = 180; 
        let allowObstacleSpawn = false;

        const PARTICLE_GRAVITY=0.2; const PARTICLE_FRICTION=0.99; const PARTICLE_LIFESPAN_FRAMES=90; const NUM_PARTICLES_ON_BREAK=12; const BOUNCE_POWER_ON_SMASH=10;
        let activeParticles = [];

        let isDashing=false; let dashDirection=0; let dashTimer=0; const DASH_DURATION_FRAMES=18; const DASH_SPEED=18; const DASH_COOLDOWN_FRAMES=75; let dashCooldownTimer=0; const DASH_STRETCH_WIDTH_FACTOR=1.6; const DASH_SQUASH_HEIGHT_FACTOR=0.6; const DASH_FALL_SPEED=downGravity*3;
        let lastTriggeredDashDirection=0;

        let isChargingSpace=false; let chargeTimer=0; const CHARGE_DURATION_FRAMES=60; let isChargeComplete=false; 
        let chargeHoldTimeoutTimer = 0; const CHARGE_HOLD_TIMEOUT_FRAMES = 120; 
        let isChargeTimeoutFlashing = false; const FLASH_INTERVAL_FRAMES = 6; 
        let chargeLockedAfterTimeout = false; 

        let chargeRingElement=null; let chargeRingPath=null; const CHARGE_RING_RADIUS_OFFSET=8; const CHARGE_RING_STROKE_WIDTH=5; let chargeTargetY=0; let chargeStartedInAir=false; const CHARGE_FLOAT_UP_SPEED_FACTOR=0.15; const CHARGE_BOB_FREQUENCY=0.1; const CHARGE_BOB_AMPLITUDE=1.5;
        let isRippleActive=false; let rippleTimer=0; const RIPPLE_DURATION_FRAMES=30; let rippleStartX=0; let rippleStartY=0; let currentRippleRadius=0; let RIPPLE_MAX_RADIUS = 1000; 
        let rippleSvgCleanupTimeoutId=null;
        let spacePressed=false; let spacePressStartTime=0; const HOLD_TO_CHARGE_DURATION_MS=180; 

        let score = 0;

        LINE_ELEMENT.style.bottom = GROUND_LEVEL + 'px';

        function calculateJumpPeakYRelative() { let tY=0;let tV=jumpPower;while(tV>0){tY+=tV;tV-=upGravity;}return tY;}
        
        function createChargeRing(){ const oldSvg=document.getElementById('charge-ring-svg');if(oldSvg&&oldSvg.parentNode){oldSvg.parentNode.removeChild(oldSvg);} chargeRingElement=null;chargeRingPath=null; chargeRingElement=document.createElementNS("http://www.w3.org/2000/svg","svg");chargeRingElement.setAttribute('id','charge-ring-svg'); const initR=(CIRCLE_BASE_WIDTH/2)+CHARGE_RING_RADIUS_OFFSET;const svgS=RIPPLE_MAX_RADIUS*2; chargeRingElement.setAttribute('width',svgS);chargeRingElement.setAttribute('height',svgS); chargeRingPath=document.createElementNS("http://www.w3.org/2000/svg","circle");chargeRingPath.setAttribute('cx',svgS/2);chargeRingPath.setAttribute('cy',svgS/2);chargeRingPath.setAttribute('r',initR);chargeRingPath.setAttribute('fill','none');chargeRingPath.setAttribute('stroke','black');chargeRingPath.setAttribute('stroke-width',CHARGE_RING_STROKE_WIDTH);const circ=2*Math.PI*initR;chargeRingPath.setAttribute('stroke-dasharray',circ);chargeRingPath.setAttribute('stroke-dashoffset',circ); chargeRingElement.appendChild(chargeRingPath);GAME_CONTAINER_ELEMENT.appendChild(chargeRingElement);chargeRingElement.style.display='none';}
        function triggerDash(){ if(isChargingSpace||isRippleActive)return;if(isJumping){isJumping=false;jumpVelocity=0;}isDashing=true;dashTimer=DASH_DURATION_FRAMES;dashCooldownTimer=DASH_COOLDOWN_FRAMES+DASH_DURATION_FRAMES;velocity=0;lastTriggeredDashDirection=dashDirection;}
        function startChargeSequence(){ if(isChargingSpace||isRippleActive)return; isChargingSpace=true;chargeTimer=0;isChargeComplete=false; chargeHoldTimeoutTimer = 0; isChargeTimeoutFlashing = false; CIRCLE_ELEMENT.style.opacity = '1'; isJumping=false;jumpVelocity=0; if(isDashing){isDashing=false;dashTimer=0;circleWidth=CIRCLE_BASE_WIDTH;circleHeight=CIRCLE_BASE_HEIGHT;CIRCLE_ELEMENT.style.filter='none';} chargeStartedInAir=(circleY>GROUND_LEVEL); if (chargeStartedInAir) { chargeTargetY = circleY; } else { let calculatedTarget = GROUND_LEVEL + maxAchievableJumpHeight + 5; chargeTargetY = Math.min(calculatedTarget, GAME_HEIGHT - circleHeight - 10); } if(rippleSvgCleanupTimeoutId){clearTimeout(rippleSvgCleanupTimeoutId);rippleSvgCleanupTimeoutId=null;}createChargeRing();if(chargeRingElement)chargeRingElement.style.display='block';}
        function performSlamAttack(){ isRippleActive=true;rippleTimer=0;rippleStartX=circleX+circleWidth/2;rippleStartY=GAME_HEIGHT-(circleY+circleHeight/2);currentRippleRadius=parseFloat(chargeRingPath.getAttribute('r'));if(chargeRingPath){chargeRingPath.style.stroke='#FF0000';chargeRingPath.setAttribute('stroke-dashoffset',0);chargeRingPath.style.opacity='0.8';} if(chargeRingElement){chargeRingElement.style.left=(rippleStartX-RIPPLE_MAX_RADIUS)+'px';chargeRingElement.style.bottom=(GAME_HEIGHT-rippleStartY-RIPPLE_MAX_RADIUS)+'px';}if(circleY>GROUND_LEVEL){isJumping=true;jumpVelocity=-3;}else{isJumping=false;}}
        function checkCircleRectCollision(circ,rect){ let tX=circ.x;let tY=circ.y;if(circ.x<rect.left)tX=rect.left;else if(circ.x>rect.right)tX=rect.right;let rBotY=GAME_HEIGHT-rect.bottom;let rTopY=GAME_HEIGHT-rect.top;if(circ.y<rBotY)tY=rBotY;else if(circ.y>rTopY)tY=rTopY;const dX=circ.x-tX;const dY=circ.y-tY;return Math.sqrt((dX*dX)+(dY*dY))<=circ.r;}
        function triggerGameOver(){ gameState='gameOver';CIRCLE_ELEMENT.style.display='none';allowObstacleSpawn=false;REPLAY_BUTTON_ELEMENT.style.display='block'; if(animationFrameId){cancelAnimationFrame(animationFrameId);animationFrameId=null;}}
        
        function startGame(){
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            GAME_WIDTH = GAME_CONTAINER_ELEMENT.offsetWidth; GAME_HEIGHT = GAME_CONTAINER_ELEMENT.offsetHeight;
            RIPPLE_MAX_RADIUS = Math.max(GAME_WIDTH, GAME_HEIGHT); maxAchievableJumpHeight = calculateJumpPeakYRelative(); 
            gameState="playing"; PLAY_BUTTON_ELEMENT.style.display='none'; REPLAY_BUTTON_ELEMENT.style.display='none'; CIRCLE_ELEMENT.style.display='block'; LINE_ELEMENT.style.display='block';
            circleX=GAME_WIDTH*0.1; circleY=GROUND_LEVEL; velocity=0; jumpVelocity=0; isJumping=false; isMovingLeft=false; isMovingRight=false; isShiftHeld=false; isDashing=false; dashCooldownTimer=0; lastTriggeredDashDirection=0; 
            isChargingSpace=false; chargeTimer=0; isChargeComplete=false; chargeHoldTimeoutTimer = 0; isChargeTimeoutFlashing = false; chargeLockedAfterTimeout = false; 
            isRippleActive=false; rippleTimer=0; spacePressed=false; spacePressStartTime=0; 
            score=0; SCORE_DISPLAY_ELEMENT.textContent="得分: "+score;
            currentObstacleSpeed = INITIAL_OBSTACLE_SPEED; lastSpeedIncreaseScore = 0; 
            trailTimer = 0;
            if(rippleSvgCleanupTimeoutId){clearTimeout(rippleSvgCleanupTimeoutId);rippleSvgCleanupTimeoutId=null;}
            const existingRingSvg=document.getElementById('charge-ring-svg'); if(existingRingSvg&&existingRingSvg.parentNode){existingRingSvg.parentNode.removeChild(existingRingSvg);} chargeRingElement=null; chargeRingPath=null; createChargeRing();
            circleWidth=CIRCLE_BASE_WIDTH; circleHeight=CIRCLE_BASE_HEIGHT; CIRCLE_ELEMENT.style.width=circleWidth+'px'; CIRCLE_ELEMENT.style.height=circleHeight+'px'; CIRCLE_ELEMENT.style.filter='none'; CIRCLE_ELEMENT.style.opacity = '1'; CIRCLE_ELEMENT.style.left=circleX+'px'; CIRCLE_ELEMENT.style.bottom=circleY+'px';
            obstacles.forEach(obsData => { if(obsData.element.parentNode === GAME_CONTAINER_ELEMENT) { GAME_CONTAINER_ELEMENT.removeChild(obsData.element); } }); obstacles.length=0; obstacleTimer=0;
            activeParticles.forEach(p=>{if(p.element.parentNode===GAME_CONTAINER_ELEMENT){GAME_CONTAINER_ELEMENT.removeChild(p.element);}}); activeParticles.length=0;
            const existingTrails = GAME_CONTAINER_ELEMENT.querySelectorAll('.trail'); existingTrails.forEach(trail => trail.remove());
            allowObstacleSpawn=false; setTimeout(()=>{if(gameState==="playing")allowObstacleSpawn=true;},3000);
            update(); 
        }
        PLAY_BUTTON_ELEMENT.addEventListener('click', startGame); REPLAY_BUTTON_ELEMENT.addEventListener('click', startGame); 
        document.addEventListener('keydown', function(event) { if(gameState==='menu'){if(event.key===' '){startGame();event.preventDefault();}return;} if(gameState==='gameOver')return; if(gameState==="playing"){ const key=event.key.toLowerCase(); if(key===' '&&!spacePressed&&!isDashing&&!isChargingSpace&&!isRippleActive){spacePressed=true;spacePressStartTime=Date.now();event.preventDefault();} let willAttemptDash=false;let newDashAttemptDirection=0; if(!isChargingSpace&&!isRippleActive){ if(key==='a'){isMovingLeft=true;if(isShiftHeld){willAttemptDash=true;newDashAttemptDirection=-1;}} else if(key==='d'){isMovingRight=true;if(isShiftHeld){willAttemptDash=true;newDashAttemptDirection=1;}} else if(event.key==='Shift'||event.code==='ShiftLeft'||event.code==='ShiftRight'){if(!isShiftHeld){if(isMovingLeft){willAttemptDash=true;newDashAttemptDirection=-1;}else if(isMovingRight){willAttemptDash=true;newDashAttemptDirection=1;}} isShiftHeld=true;}} if(willAttemptDash&&newDashAttemptDirection!==0){ if(isDashing){ if(dashDirection!==newDashAttemptDirection){isDashing=false;dashTimer=0;circleWidth=CIRCLE_BASE_WIDTH;circleHeight=CIRCLE_BASE_HEIGHT;CIRCLE_ELEMENT.style.width=circleWidth+'px';CIRCLE_ELEMENT.style.height=circleHeight+'px';CIRCLE_ELEMENT.style.filter='none';dashDirection=newDashAttemptDirection;triggerDash();}} else{ if(dashCooldownTimer<=0){dashDirection=newDashAttemptDirection;triggerDash();} else{if(lastTriggeredDashDirection!==0&&newDashAttemptDirection!==lastTriggeredDashDirection){dashDirection=newDashAttemptDirection;triggerDash();}}}}}});
        document.addEventListener('keyup', function(event) { if(gameState==='gameOver')return; if(gameState==="playing"){ const key=event.key.toLowerCase(); if(key===' '){if(spacePressed){ if(isChargingSpace){ CIRCLE_ELEMENT.style.opacity = '1'; if(isChargeComplete){ performSlamAttack(); } else{ if(circleY>GROUND_LEVEL){isJumping=true;jumpVelocity=-1;} else{isJumping=false;} if(chargeRingElement&&chargeRingElement.parentNode&&!isRippleActive){GAME_CONTAINER_ELEMENT.removeChild(chargeRingElement);chargeRingElement=null;chargeRingPath=null;}} isChargingSpace=false; isChargeComplete=false; chargeHoldTimeoutTimer = 0; isChargeTimeoutFlashing = false; } else{ let onSupport=circleY===GROUND_LEVEL; if(!onSupport){ for(const oData of obstacles){if(!oData.isFalling){const o=oData.element; const oTop=oData.y+o.offsetHeight;if(Math.abs(circleY-oTop)<5){const oL=oData.x;const oW=o.offsetWidth;if(circleX<oL+oW&&circleX+circleWidth>oL){onSupport=true;break;}}}}} if(onSupport&&!isJumping&&!isDashing&&!isRippleActive){isJumping=true;jumpVelocity=jumpPower;}}} spacePressed=false;spacePressStartTime=0; chargeLockedAfterTimeout = false; } if(key==='a')isMovingLeft=false; else if(key==='d')isMovingRight=false; else if(event.key==='Shift'||event.code==='ShiftLeft'||event.code==='ShiftRight')isShiftHeld=false;}});

        function createAndAddParticle(x,y,vx,vy){const p=document.createElement('div');p.classList.add('particle');p.style.left=x+'px';p.style.bottom=y+'px';GAME_CONTAINER_ELEMENT.appendChild(p);activeParticles.push({element:p,x:x,y:y,vx:vx,vy:vy,life:PARTICLE_LIFESPAN_FRAMES});}
        function spawnParticlesFromObstacle(oElem){const cX=oElem.offsetLeft+oElem.offsetWidth/2;const cY=parseFloat(oElem.style.bottom)+oElem.offsetHeight/2;for(let i=0;i<NUM_PARTICLES_ON_BREAK;i++){const a=Math.random()*Math.PI*2;const s=Math.random()*4+1.5;createAndAddParticle(cX-3,cY-3,Math.cos(a)*s,Math.sin(a)*s);}}
        
        function createObstacle() { 
            const obstacleElement = document.createElement('div');
            obstacleElement.classList.add('obstacle');
            const maxJumpHeightPixels = maxAchievableJumpHeight; 
            const width = Math.floor(Math.random() * (obstacleMaxWidth - obstacleMinWidth + 1)) + obstacleMinWidth;
            let height = Math.floor(Math.random() * (obstacleMaxHeight - obstacleMinHeight + 1)) + obstacleMinHeight; 
            height = Math.min(height, maxJumpHeightPixels); height = Math.max(height, 10); 
            obstacleElement.style.width = width + 'px'; obstacleElement.style.height = height + 'px';
            const startX = GAME_WIDTH + 50; const startY = GAME_HEIGHT + Math.random() * 50; 
            obstacleElement.style.left = startX + 'px'; obstacleElement.style.bottom = startY + 'px';
            GAME_CONTAINER_ELEMENT.appendChild(obstacleElement);
            obstacles.push({ element: obstacleElement, x: startX, y: startY, vy: 0, isFalling: true }); 
        }
        
        function checkRectCollision(r1,r2){ return (r1.left < r2.right && r1.right > r2.left && r1.top < r2.bottom && r1.bottom > r2.top); }
        function getGameRelativeRect(xL,yB,w,h){ return {left:xL,top:GAME_HEIGHT-(yB+h),right:xL+w,bottom:GAME_HEIGHT-yB};}
        
        function getCollidingObstacleDataAt(targetCircleX, currentCircleY, currentCircleWidth, currentCircleHeight) {
            const proposedCircleRect = getGameRelativeRect(targetCircleX, currentCircleY, currentCircleWidth, currentCircleHeight);
            for (const obsData of obstacles) {
                if (!obsData.isFalling) { 
                    const obstacleElement = obsData.element;
                    const obsRect = getGameRelativeRect(obsData.x, obsData.y, obstacleElement.offsetWidth, obstacleElement.offsetHeight);
                    if (checkRectCollision(proposedCircleRect, obsRect)) {
                        return obsData; 
                    }
                }
            }
            return null; 
        }

        function update() {
            if (gameState === 'gameOver') { return; } 
            if (gameState === "playing") {
                let circleYBeforeUpdate = circleY;
                if (dashCooldownTimer > 0) dashCooldownTimer--;

                if (spacePressed && !isChargingSpace && !isRippleActive && !isDashing && !chargeLockedAfterTimeout) { if (Date.now() - spacePressStartTime >= HOLD_TO_CHARGE_DURATION_MS) { startChargeSequence(); } }

                if (isRippleActive) { /* ... ripple logic ... */ 
                     rippleTimer++; const rProg = rippleTimer / RIPPLE_DURATION_FRAMES; const initR = (CIRCLE_BASE_WIDTH / 2) + CHARGE_RING_RADIUS_OFFSET; currentRippleRadius = initR + (RIPPLE_MAX_RADIUS - initR) * rProg; if (chargeRingPath) { chargeRingPath.setAttribute('r', currentRippleRadius); chargeRingPath.style.opacity = Math.max(0, 0.8 - rProg * 0.8).toString(); } if (chargeRingElement) { chargeRingElement.style.left = (rippleStartX - RIPPLE_MAX_RADIUS) + 'px'; chargeRingElement.style.bottom = (GAME_HEIGHT - rippleStartY - RIPPLE_MAX_RADIUS) + 'px'; } const rippleCirc = { x: rippleStartX, y: GAME_HEIGHT - rippleStartY, r: currentRippleRadius }; for (let i = obstacles.length - 1; i >= 0; i--) { const oData = obstacles[i]; const o = oData.element; const oRect = { left: oData.x, right: oData.x + o.offsetWidth, top: GAME_HEIGHT - (oData.y + o.offsetHeight), bottom: GAME_HEIGHT - oData.y }; if (checkCircleRectCollision(rippleCirc, oRect)) { score++; spawnParticlesFromObstacle(o); GAME_CONTAINER_ELEMENT.removeChild(o); obstacles.splice(i, 1); } } if (rippleTimer >= RIPPLE_DURATION_FRAMES) { isRippleActive = false; rippleTimer = 0; if (chargeRingElement && chargeRingElement.parentNode) { GAME_CONTAINER_ELEMENT.removeChild(chargeRingElement); chargeRingElement = null; chargeRingPath = null; } if (rippleSvgCleanupTimeoutId) { clearTimeout(rippleSvgCleanupTimeoutId); rippleSvgCleanupTimeoutId = null; } }
                }
                else if (isChargingSpace) { /* ... charging logic with timeout ... */ 
                     isJumping = false; jumpVelocity = 0; 
                    if (chargeStartedInAir) { circleY = chargeTargetY + Math.sin(chargeTimer * CHARGE_BOB_FREQUENCY) * CHARGE_BOB_AMPLITUDE; } 
                    else { if (circleY < chargeTargetY && chargeTimer < CHARGE_DURATION_FRAMES * 0.35) { circleY += (chargeTargetY - circleY) * CHARGE_FLOAT_UP_SPEED_FACTOR; if (circleY > chargeTargetY) circleY = chargeTargetY; } else { circleY = chargeTargetY; } } 
                    if (circleY + circleHeight > GAME_HEIGHT) circleY = GAME_HEIGHT - circleHeight; if (circleY < GROUND_LEVEL) circleY = GROUND_LEVEL; 
                    chargeTimer++; const cProg = Math.min(chargeTimer / CHARGE_DURATION_FRAMES, 1);
                    if (chargeRingElement && chargeRingPath) { const initR = (CIRCLE_BASE_WIDTH / 2) + CHARGE_RING_RADIUS_OFFSET; chargeRingPath.setAttribute('r', initR); const circ = 2 * Math.PI * initR; chargeRingPath.setAttribute('stroke-dashoffset', circ * (1 - cProg)); const svgCX = circleX + CIRCLE_BASE_WIDTH / 2; const svgCY = circleY + CIRCLE_BASE_HEIGHT / 2; chargeRingElement.style.left = (svgCX - RIPPLE_MAX_RADIUS) + 'px'; chargeRingElement.style.bottom = (svgCY - RIPPLE_MAX_RADIUS) + 'px'; } 
                    if (cProg >= 1 && !isChargeComplete) { isChargeComplete = true; chargeHoldTimeoutTimer = 0; if (chargeRingPath) chargeRingPath.style.stroke = '#FF5733'; }
                    if (isChargeComplete) { chargeHoldTimeoutTimer++; if (chargeHoldTimeoutTimer > CHARGE_HOLD_TIMEOUT_FRAMES) { isChargingSpace = false; isChargeComplete = false; chargeHoldTimeoutTimer = 0; isChargeTimeoutFlashing = false; chargeLockedAfterTimeout = true; CIRCLE_ELEMENT.style.opacity = '1'; if (circleY > GROUND_LEVEL) { isJumping = true; jumpVelocity = -1; } else { isJumping = false; } if (chargeRingElement && chargeRingElement.parentNode) { GAME_CONTAINER_ELEMENT.removeChild(chargeRingElement); chargeRingElement = null; chargeRingPath = null; } } else { isChargeTimeoutFlashing = (chargeHoldTimeoutTimer % (FLASH_INTERVAL_FRAMES * 2)) < FLASH_INTERVAL_FRAMES; CIRCLE_ELEMENT.style.opacity = isChargeTimeoutFlashing ? '1' : '0.4'; } }
                } else if (isDashing) { /* ... dashing logic ... */ 
                    dashTimer--; circleWidth = CIRCLE_BASE_WIDTH*DASH_STRETCH_WIDTH_FACTOR; circleHeight = CIRCLE_BASE_HEIGHT*DASH_SQUASH_HEIGHT_FACTOR; CIRCLE_ELEMENT.style.filter='blur(1.5px)'; let tX=circleX; for(let d=0;d<DASH_SPEED;d++){if(!isDashing)break; let nX=tX+dashDirection; if(nX<0){tX=0;isDashing=false;break;}if(nX+circleWidth>GAME_WIDTH){tX=GAME_WIDTH-circleWidth;isDashing=false;break;} const dRect=getGameRelativeRect(nX,circleY,circleWidth,circleHeight); for(let i=obstacles.length-1;i>=0;i--){const oData=obstacles[i]; const o=oData.element; const oRect=getGameRelativeRect(oData.x,oData.y,o.offsetWidth,o.offsetHeight);if(checkRectCollision(dRect,oRect)){const pT=circleY+circleHeight;const pB=circleY;const oT=oData.y+o.offsetHeight;const oB=oData.y;if(pB<oT&&pT>oB){score++; spawnParticlesFromObstacle(o);GAME_CONTAINER_ELEMENT.removeChild(o);obstacles.splice(i,1);}}}tX=nX;} circleX=tX; if(circleY>GROUND_LEVEL){circleY-=DASH_FALL_SPEED;if(circleY<GROUND_LEVEL)circleY=GROUND_LEVEL;} if(dashTimer<=0)isDashing=false; if(!isDashing){circleWidth=CIRCLE_BASE_WIDTH;circleHeight=CIRCLE_BASE_HEIGHT;CIRCLE_ELEMENT.style.filter='none';}
                } else { // Normal Movement / Jumping
                    if(circleWidth!==CIRCLE_BASE_WIDTH||CIRCLE_ELEMENT.style.filter!=='none'){circleWidth=CIRCLE_BASE_WIDTH;circleHeight=CIRCLE_BASE_HEIGHT;CIRCLE_ELEMENT.style.filter='none';}
                    if(isMovingLeft)velocity=Math.max(velocity-acceleration,-maxVelocity); else if(isMovingRight)velocity=Math.min(velocity+acceleration,maxVelocity); else{if(velocity>0)velocity=Math.max(0,velocity-deceleration);else if(velocity<0)velocity=Math.min(0,velocity+deceleration);}
                    if (velocity !== 0) { /* ... horizontal movement check ... */ 
                        let tempProposedX = circleX; const step = velocity > 0 ? 1 : -1;
                        for (let i = 0; i < Math.floor(Math.abs(velocity)); i++) {
                            let nextX = tempProposedX + step;
                            // Removed boundary check here, push handles game over
                            if (nextX + circleWidth > GAME_WIDTH) { tempProposedX = GAME_WIDTH - circleWidth; velocity = 0; break; }
                            const collidingObsData = getCollidingObstacleDataAt(nextX, circleY, circleWidth, circleHeight); 
                            if (collidingObsData) { const obstacleElement = collidingObsData.element; const obsTopSurfaceY = collidingObsData.y + obstacleElement.offsetHeight; if (circleY < obsTopSurfaceY - 1) { if (step > 0) { tempProposedX = collidingObsData.x - circleWidth; } else { tempProposedX = collidingObsData.x + obstacleElement.offsetWidth; } velocity = 0; break; } }
                            tempProposedX = nextX;
                        }
                        circleX = tempProposedX;
                    }
                    const prevY=circleYBeforeUpdate; let landed=false;
                    if(isJumping){ /* ... Jump / Fall / Stomp logic ... */
                        circleY+=jumpVelocity;if(jumpVelocity>0)jumpVelocity-=upGravity;else jumpVelocity-=downGravity; if(circleY+circleHeight>GAME_HEIGHT){circleY=GAME_HEIGHT-circleHeight;jumpVelocity=0;} if(circleY<=GROUND_LEVEL){circleY=GROUND_LEVEL;isJumping=false;jumpVelocity=0;landed=true;} 
                        else if(jumpVelocity<=0&&!landed){const cRect=getGameRelativeRect(circleX,circleY,circleWidth,circleHeight);for(let i=obstacles.length-1;i>=0;i--){const oData=obstacles[i];const o=oData.element;const oTop=oData.y+o.offsetHeight;const oRect=getGameRelativeRect(oData.x,oData.y,o.offsetWidth,o.offsetHeight);if(checkRectCollision(cRect,oRect)){if(circleY<=oTop&&prevY+1>=oTop&&(circleX+circleWidth>oData.x+2&&circleX<oData.x+o.offsetWidth-2)){score++; spawnParticlesFromObstacle(o);GAME_CONTAINER_ELEMENT.removeChild(o);obstacles.splice(i,1);circleY=oTop+0.1;jumpVelocity=BOUNCE_POWER_ON_SMASH;isJumping=true;break;}}}}}
                    
                    if(!isJumping&&circleY>GROUND_LEVEL){ /* ... Support check ... */
                        let supp=false;let hY=GROUND_LEVEL;for(const oData of obstacles){if(!oData.isFalling){ const o=oData.element; const oL=oData.x;const oR=oL+o.offsetWidth;const oTop=oData.y+o.offsetHeight;const hO=(circleX<oR&&circleX+circleWidth>oL);if(hO&&Math.abs(circleY-oTop)<2){if(oTop>hY)hY=oTop;supp=true;}}}if(supp){circleY=hY;isJumping=false;jumpVelocity=0;}else{isJumping=true;jumpVelocity=0;}
                    }
                    if(!isJumping&&circleY<GROUND_LEVEL)circleY=GROUND_LEVEL;
                }

                CIRCLE_ELEMENT.style.width = circleWidth + 'px'; CIRCLE_ELEMENT.style.height = circleHeight + 'px';
                CIRCLE_ELEMENT.style.left = circleX + 'px'; CIRCLE_ELEMENT.style.bottom = circleY + 'px';

                // REMOVED general left boundary check

                if (allowObstacleSpawn) {
                    obstacleTimer++;
                    if (obstacleTimer >= (Math.random() * (obstacleSpawnIntervalMax - obstacleSpawnIntervalMin) + obstacleSpawnIntervalMin)) { createObstacle(); obstacleTimer = 0; }
                }

                // Obstacle update loop
                for (let i = obstacles.length - 1; i >= 0; i--) { 
                    const obsData = obstacles[i]; 
                    const obstacleElement = obsData.element; 
                    if (obsData.isFalling) {
                        obsData.vy -= obstacleGravity; obsData.y += obsData.vy;
                        if (obsData.y <= GROUND_LEVEL) { obsData.y = GROUND_LEVEL; obsData.vy = 0; obsData.isFalling = false; }
                    }
                    obsData.x -= currentObstacleSpeed; 
                    obstacleElement.style.left = obsData.x + 'px'; obstacleElement.style.bottom = obsData.y + 'px';
                    
                    // Side Collision (Pushing) - check applies during charge now
                    if (!isRippleActive && !isDashing && !obsData.isFalling) { 
                         const currentCircleRect = getGameRelativeRect(circleX, circleY, circleWidth, circleHeight);
                         const obstacleRectForPush = getGameRelativeRect(obsData.x, obsData.y, obstacleElement.offsetWidth, obstacleElement.offsetHeight);
                         if (checkRectCollision(currentCircleRect, obstacleRectForPush)) {
                             const onTop = !isJumping && Math.abs(circleY - (obsData.y + obstacleElement.offsetHeight)) < 2 && (circleX < obsData.x + obstacleElement.offsetWidth && circleX + circleWidth > obsData.x);
                             if (!onTop) { 
                                 const oC = obsData.x + obstacleElement.offsetWidth / 2; const cC = circleX + circleWidth / 2; let pX = circleX; if (oC > cC) pX -= pushForce; else pX += pushForce; 
                                 // Don't clamp pX to 0 here yet
                                 if (pX + circleWidth > GAME_WIDTH) pX = GAME_WIDTH - circleWidth;
                                 
                                 let canP = true; const pRect = getGameRelativeRect(pX, circleY, circleWidth, circleHeight);
                                 for (const otherOData of obstacles) { if (otherOData === obsData) continue; const otherO = otherOData.element; const otherRect = getGameRelativeRect(otherOData.x, otherOData.y, otherO.offsetWidth, otherO.offsetHeight); if (checkRectCollision(pRect, otherRect)) { canP = false; break; } }
                                 
                                 if (canP) { 
                                     circleX = pX; 
                                     CIRCLE_ELEMENT.style.left = circleX + 'px'; 
                                     // ADDED: Check for game over IMMEDIATELY after being pushed past edge
                                     if (circleX <= 0) { 
                                         triggerGameOver(); 
                                         return; // Exit update loop immediately
                                     }
                                 }
                             }
                         }
                     }
                    
                    if (obsData.x + obstacleElement.offsetWidth < 0) { score++; GAME_CONTAINER_ELEMENT.removeChild(obstacleElement); obstacles.splice(i, 1); }
                } // End obstacle loop

                 // Particle update loop
                 for (let i = activeParticles.length - 1; i >= 0; i--) {/*same*/ const p = activeParticles[i]; p.vy -= PARTICLE_GRAVITY; p.vx *= PARTICLE_FRICTION; p.vy *= PARTICLE_FRICTION; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0 || p.y < -10 || p.x < -10 || p.x > GAME_WIDTH + 10 ) { if (p.element.parentNode === GAME_CONTAINER_ELEMENT) GAME_CONTAINER_ELEMENT.removeChild(p.element); activeParticles.splice(i, 1); } else { p.element.style.left = p.x + 'px'; p.element.style.bottom = p.y + 'px'; } }
                
                // Difficulty Increase Check
                if (score > 0 && score % 10 === 0 && score > lastSpeedIncreaseScore) {
                    currentObstacleSpeed += OBSTACLE_SPEED_INCREMENT;
                    lastSpeedIncreaseScore = score;
                }

                SCORE_DISPLAY_ELEMENT.textContent = "得分: " + score;

            } else if (gameState === "menu") { /* Menu logic */ } 
            
            if (gameState !== 'gameOver') { 
                animationFrameId = requestAnimationFrame(update); 
            } else {
                animationFrameId = null; 
            }
        }
        // Initial call removed
    </script>
</body>
</html>